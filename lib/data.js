import { Amplify } from 'aws-amplify';
import { generateClient } from 'aws-amplify/data';

// Configure Amplify for server-side usage
// The amplify_outputs.json is generated by `ampx pipeline-deploy` during CI/CD
let configured = false;
try {
  const outputs = await import('../amplify_outputs.json', { with: { type: 'json' } });
  Amplify.configure(outputs.default, { ssr: true });
  configured = true;
} catch (e) {
  console.warn('amplify_outputs.json not found - run `npx ampx sandbox` to generate');
}

/**
 * Amplify Data client for GraphQL operations
 * @type {import('aws-amplify/data').Client<import('../amplify/data/resource').Schema>}
 */
const client = configured ? generateClient() : null;

// Helper to check if client is available
function requireClient() {
  if (!client) {
    throw new Error('Amplify not configured. Run `npx ampx sandbox` to start local development.');
  }
  return client;
}

// ==================== USERS ====================

export async function getUsers() {
  const { data, errors } = await requireClient().models.User.list();
  if (errors) {
    console.error('Error fetching users:', errors);
    return [];
  }
  return data || [];
}

export async function getUserById(id) {
  const { data, errors } = await requireClient().models.User.get({ id });
  if (errors) {
    console.error('Error fetching user:', errors);
    return null;
  }
  return data || null;
}

export async function getUserByUsername(username) {
  const { data, errors } = await requireClient().models.User.list({
    filter: { username: { eq: username } },
  });
  if (errors) {
    console.error('Error fetching user by username:', errors);
    return null;
  }
  return data?.[0] || null;
}

export async function createUser(user) {
  const { data, errors } = await requireClient().models.User.create({
    username: user.username,
    displayName: user.displayName,
    role: user.role,
    avatar: user.avatar || null,
  });
  if (errors) {
    console.error('Error creating user:', errors);
    throw new Error('Failed to create user');
  }
  return data.id;
}

// ==================== CHORES ====================

export async function getChores() {
  const { data, errors } = await requireClient().models.Chore.list();
  if (errors) {
    console.error('Error fetching chores:', errors);
    return [];
  }
  return data || [];
}

export async function getChoreById(id) {
  const { data, errors } = await requireClient().models.Chore.get({ id });
  if (errors) {
    console.error('Error fetching chore:', errors);
    return null;
  }
  return data || null;
}

export async function addChore(chore) {
  const { data, errors } = await requireClient().models.Chore.create({
    title: chore.title,
    assignedTo: chore.assigned_to || chore.assignedTo,
    paid: chore.paid ? true : false,
    amount: chore.amount || 0,
    done: false,
    approved: false,
    completedAt: null,
    recurring: chore.recurring || null,
    lastReset: null,
  });
  if (errors) {
    console.error('Error creating chore:', errors);
    throw new Error('Failed to create chore');
  }
  return data.id;
}

export async function updateChore(id, updates) {
  // Convert snake_case to camelCase
  const cleanUpdates = {};
  for (const [key, value] of Object.entries(updates)) {
    const dbKey = key === 'assigned_to' ? 'assignedTo'
               : key === 'completed_at' ? 'completedAt'
               : key === 'last_reset' ? 'lastReset'
               : key;
    cleanUpdates[dbKey] = value;
  }

  const { errors } = await requireClient().models.Chore.update({
    id,
    ...cleanUpdates,
  });
  if (errors) {
    console.error('Error updating chore:', errors);
    throw new Error('Failed to update chore');
  }
}

export async function deleteChore(id) {
  const { errors } = await requireClient().models.Chore.delete({ id });
  if (errors) {
    console.error('Error deleting chore:', errors);
    throw new Error('Failed to delete chore');
  }
}

export async function resetRecurringChores() {
  const chores = await getChores();
  const now = new Date();
  const today = now.toDateString();

  for (const chore of chores) {
    if (!chore.recurring) continue;

    const lastReset = chore.lastReset ? new Date(chore.lastReset) : null;
    const lastResetDay = lastReset?.toDateString();

    if (lastResetDay === today) continue;

    let shouldReset = false;

    if (chore.recurring === 'daily') {
      shouldReset = true;
    } else if (chore.recurring === 'weekly') {
      const daysSince = lastReset
        ? Math.floor((now - lastReset) / (1000 * 60 * 60 * 24))
        : 999;
      shouldReset = daysSince >= 7;
    }

    if (shouldReset) {
      await updateChore(chore.id, {
        done: false,
        approved: false,
        completedAt: null,
        lastReset: now.toISOString(),
      });
    }
  }
}

// ==================== MEALS ====================

export async function getMeals() {
  const { data, errors } = await requireClient().models.Meal.list();
  if (errors) {
    console.error('Error fetching meals:', errors);
    return [];
  }
  return data || [];
}

export async function getMealByDateAndType(date, type) {
  const { data, errors } = await requireClient().models.Meal.list({
    filter: {
      date: { eq: date },
      mealType: { eq: type },
    },
  });
  if (errors) {
    console.error('Error fetching meal:', errors);
    return null;
  }
  return data?.[0] || null;
}

export async function setMeal(date, mealType, meal, mealId = null) {
  const existing = await getMealByDateAndType(date, mealType);

  if (existing) {
    if (meal) {
      // Update existing
      const { errors } = await requireClient().models.Meal.update({
        id: existing.id,
        meal,
        mealId,
      });
      if (errors) {
        console.error('Error updating meal:', errors);
        throw new Error('Failed to update meal');
      }
    } else {
      // Delete if meal is empty
      const { errors } = await requireClient().models.Meal.delete({ id: existing.id });
      if (errors) {
        console.error('Error deleting meal:', errors);
        throw new Error('Failed to delete meal');
      }
    }
  } else if (meal) {
    // Create new
    const { errors } = await requireClient().models.Meal.create({
      date,
      mealType,
      meal,
      mealId,
    });
    if (errors) {
      console.error('Error creating meal:', errors);
      throw new Error('Failed to create meal');
    }
  }
}

// ==================== SHOPPING ====================

export async function getShoppingItems() {
  const { data, errors } = await requireClient().models.ShoppingItem.list();
  if (errors) {
    console.error('Error fetching shopping items:', errors);
    return [];
  }
  return data || [];
}

export async function addShoppingItem(item) {
  const { data, errors } = await requireClient().models.ShoppingItem.create({
    name: item.name,
    quantity: item.quantity || 1,
    estimatedCost: item.estimated_cost || item.estimatedCost || null,
    addedBy: item.added_by || item.addedBy || null,
    checked: false,
  });
  if (errors) {
    console.error('Error creating shopping item:', errors);
    throw new Error('Failed to create shopping item');
  }
  return data.id;
}

export async function updateShoppingItem(id, updates) {
  // Convert snake_case to camelCase
  const cleanUpdates = {};
  for (const [key, value] of Object.entries(updates)) {
    const dbKey = key === 'estimated_cost' ? 'estimatedCost'
               : key === 'added_by' ? 'addedBy'
               : key;
    cleanUpdates[dbKey] = value;
  }

  const { errors } = await requireClient().models.ShoppingItem.update({
    id,
    ...cleanUpdates,
  });
  if (errors) {
    console.error('Error updating shopping item:', errors);
    throw new Error('Failed to update shopping item');
  }
}

export async function deleteShoppingItem(id) {
  const { errors } = await requireClient().models.ShoppingItem.delete({ id });
  if (errors) {
    console.error('Error deleting shopping item:', errors);
    throw new Error('Failed to delete shopping item');
  }
}

export async function clearCheckedItems() {
  const items = await getShoppingItems();
  const checkedItems = items.filter((i) => i.checked);

  for (const item of checkedItems) {
    await deleteShoppingItem(item.id);
  }
}

// ==================== EARNINGS ====================

export async function getEarnings() {
  const users = await getUsers();
  const chores = await getChores();
  const children = users.filter((u) => u.role === 'child');

  return children.map((child) => {
    const approvedChores = chores.filter(
      (c) => c.assignedTo === child.id && c.approved && c.paid
    );
    const total = approvedChores.reduce((sum, c) => sum + (c.amount || 0), 0);
    return {
      user: child,
      total,
      chores: approvedChores.length,
    };
  });
}
